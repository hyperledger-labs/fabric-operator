// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-operator/pkg/initializer/common"
	baseorderer "github.com/IBM-Blockchain/fabric-operator/pkg/offering/base/orderer"
)

type Update struct {
	CertificateCreatedStub        func() bool
	certificateCreatedMutex       sync.RWMutex
	certificateCreatedArgsForCall []struct {
	}
	certificateCreatedReturns struct {
		result1 bool
	}
	certificateCreatedReturnsOnCall map[int]struct {
		result1 bool
	}
	CertificateUpdatedStub        func() bool
	certificateUpdatedMutex       sync.RWMutex
	certificateUpdatedArgsForCall []struct {
	}
	certificateUpdatedReturns struct {
		result1 bool
	}
	certificateUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	ConfigOverridesUpdatedStub        func() bool
	configOverridesUpdatedMutex       sync.RWMutex
	configOverridesUpdatedArgsForCall []struct {
	}
	configOverridesUpdatedReturns struct {
		result1 bool
	}
	configOverridesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	CryptoBackupNeededStub        func() bool
	cryptoBackupNeededMutex       sync.RWMutex
	cryptoBackupNeededArgsForCall []struct {
	}
	cryptoBackupNeededReturns struct {
		result1 bool
	}
	cryptoBackupNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	DeploymentUpdatedStub        func() bool
	deploymentUpdatedMutex       sync.RWMutex
	deploymentUpdatedArgsForCall []struct {
	}
	deploymentUpdatedReturns struct {
		result1 bool
	}
	deploymentUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertEnrollStub        func() bool
	ecertEnrollMutex       sync.RWMutex
	ecertEnrollArgsForCall []struct {
	}
	ecertEnrollReturns struct {
		result1 bool
	}
	ecertEnrollReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertNewKeyReenrollStub        func() bool
	ecertNewKeyReenrollMutex       sync.RWMutex
	ecertNewKeyReenrollArgsForCall []struct {
	}
	ecertNewKeyReenrollReturns struct {
		result1 bool
	}
	ecertNewKeyReenrollReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertReenrollNeededStub        func() bool
	ecertReenrollNeededMutex       sync.RWMutex
	ecertReenrollNeededArgsForCall []struct {
	}
	ecertReenrollNeededReturns struct {
		result1 bool
	}
	ecertReenrollNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertUpdatedStub        func() bool
	ecertUpdatedMutex       sync.RWMutex
	ecertUpdatedArgsForCall []struct {
	}
	ecertUpdatedReturns struct {
		result1 bool
	}
	ecertUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	FabricVersionUpdatedStub        func() bool
	fabricVersionUpdatedMutex       sync.RWMutex
	fabricVersionUpdatedArgsForCall []struct {
	}
	fabricVersionUpdatedReturns struct {
		result1 bool
	}
	fabricVersionUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	GetCreatedCertTypeStub        func() common.SecretType
	getCreatedCertTypeMutex       sync.RWMutex
	getCreatedCertTypeArgsForCall []struct {
	}
	getCreatedCertTypeReturns struct {
		result1 common.SecretType
	}
	getCreatedCertTypeReturnsOnCall map[int]struct {
		result1 common.SecretType
	}
	ImagesUpdatedStub        func() bool
	imagesUpdatedMutex       sync.RWMutex
	imagesUpdatedArgsForCall []struct {
	}
	imagesUpdatedReturns struct {
		result1 bool
	}
	imagesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	MSPUpdatedStub        func() bool
	mSPUpdatedMutex       sync.RWMutex
	mSPUpdatedArgsForCall []struct {
	}
	mSPUpdatedReturns struct {
		result1 bool
	}
	mSPUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	MigrateToV2Stub        func() bool
	migrateToV2Mutex       sync.RWMutex
	migrateToV2ArgsForCall []struct {
	}
	migrateToV2Returns struct {
		result1 bool
	}
	migrateToV2ReturnsOnCall map[int]struct {
		result1 bool
	}
	MigrateToV24Stub        func() bool
	migrateToV24Mutex       sync.RWMutex
	migrateToV24ArgsForCall []struct {
	}
	migrateToV24Returns struct {
		result1 bool
	}
	migrateToV24ReturnsOnCall map[int]struct {
		result1 bool
	}
	MigrateToV25Stub        func() bool
	migrateToV25Mutex       sync.RWMutex
	migrateToV25ArgsForCall []struct {
	}
	migrateToV25Returns struct {
		result1 bool
	}
	migrateToV25ReturnsOnCall map[int]struct {
		result1 bool
	}
	NodeOUUpdatedStub        func() bool
	nodeOUUpdatedMutex       sync.RWMutex
	nodeOUUpdatedArgsForCall []struct {
	}
	nodeOUUpdatedReturns struct {
		result1 bool
	}
	nodeOUUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	OrdererTagUpdatedStub        func() bool
	ordererTagUpdatedMutex       sync.RWMutex
	ordererTagUpdatedArgsForCall []struct {
	}
	ordererTagUpdatedReturns struct {
		result1 bool
	}
	ordererTagUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	RestartNeededStub        func() bool
	restartNeededMutex       sync.RWMutex
	restartNeededArgsForCall []struct {
	}
	restartNeededReturns struct {
		result1 bool
	}
	restartNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	SpecUpdatedStub        func() bool
	specUpdatedMutex       sync.RWMutex
	specUpdatedArgsForCall []struct {
	}
	specUpdatedReturns struct {
		result1 bool
	}
	specUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	TLSCertUpdatedStub        func() bool
	tLSCertUpdatedMutex       sync.RWMutex
	tLSCertUpdatedArgsForCall []struct {
	}
	tLSCertUpdatedReturns struct {
		result1 bool
	}
	tLSCertUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	TLScertEnrollStub        func() bool
	tLScertEnrollMutex       sync.RWMutex
	tLScertEnrollArgsForCall []struct {
	}
	tLScertEnrollReturns struct {
		result1 bool
	}
	tLScertEnrollReturnsOnCall map[int]struct {
		result1 bool
	}
	TLScertNewKeyReenrollStub        func() bool
	tLScertNewKeyReenrollMutex       sync.RWMutex
	tLScertNewKeyReenrollArgsForCall []struct {
	}
	tLScertNewKeyReenrollReturns struct {
		result1 bool
	}
	tLScertNewKeyReenrollReturnsOnCall map[int]struct {
		result1 bool
	}
	TLScertReenrollNeededStub        func() bool
	tLScertReenrollNeededMutex       sync.RWMutex
	tLScertReenrollNeededArgsForCall []struct {
	}
	tLScertReenrollNeededReturns struct {
		result1 bool
	}
	tLScertReenrollNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Update) CertificateCreated() bool {
	fake.certificateCreatedMutex.Lock()
	ret, specificReturn := fake.certificateCreatedReturnsOnCall[len(fake.certificateCreatedArgsForCall)]
	fake.certificateCreatedArgsForCall = append(fake.certificateCreatedArgsForCall, struct {
	}{})
	stub := fake.CertificateCreatedStub
	fakeReturns := fake.certificateCreatedReturns
	fake.recordInvocation("CertificateCreated", []interface{}{})
	fake.certificateCreatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) CertificateCreatedCallCount() int {
	fake.certificateCreatedMutex.RLock()
	defer fake.certificateCreatedMutex.RUnlock()
	return len(fake.certificateCreatedArgsForCall)
}

func (fake *Update) CertificateCreatedCalls(stub func() bool) {
	fake.certificateCreatedMutex.Lock()
	defer fake.certificateCreatedMutex.Unlock()
	fake.CertificateCreatedStub = stub
}

func (fake *Update) CertificateCreatedReturns(result1 bool) {
	fake.certificateCreatedMutex.Lock()
	defer fake.certificateCreatedMutex.Unlock()
	fake.CertificateCreatedStub = nil
	fake.certificateCreatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CertificateCreatedReturnsOnCall(i int, result1 bool) {
	fake.certificateCreatedMutex.Lock()
	defer fake.certificateCreatedMutex.Unlock()
	fake.CertificateCreatedStub = nil
	if fake.certificateCreatedReturnsOnCall == nil {
		fake.certificateCreatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.certificateCreatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CertificateUpdated() bool {
	fake.certificateUpdatedMutex.Lock()
	ret, specificReturn := fake.certificateUpdatedReturnsOnCall[len(fake.certificateUpdatedArgsForCall)]
	fake.certificateUpdatedArgsForCall = append(fake.certificateUpdatedArgsForCall, struct {
	}{})
	stub := fake.CertificateUpdatedStub
	fakeReturns := fake.certificateUpdatedReturns
	fake.recordInvocation("CertificateUpdated", []interface{}{})
	fake.certificateUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) CertificateUpdatedCallCount() int {
	fake.certificateUpdatedMutex.RLock()
	defer fake.certificateUpdatedMutex.RUnlock()
	return len(fake.certificateUpdatedArgsForCall)
}

func (fake *Update) CertificateUpdatedCalls(stub func() bool) {
	fake.certificateUpdatedMutex.Lock()
	defer fake.certificateUpdatedMutex.Unlock()
	fake.CertificateUpdatedStub = stub
}

func (fake *Update) CertificateUpdatedReturns(result1 bool) {
	fake.certificateUpdatedMutex.Lock()
	defer fake.certificateUpdatedMutex.Unlock()
	fake.CertificateUpdatedStub = nil
	fake.certificateUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CertificateUpdatedReturnsOnCall(i int, result1 bool) {
	fake.certificateUpdatedMutex.Lock()
	defer fake.certificateUpdatedMutex.Unlock()
	fake.CertificateUpdatedStub = nil
	if fake.certificateUpdatedReturnsOnCall == nil {
		fake.certificateUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.certificateUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ConfigOverridesUpdated() bool {
	fake.configOverridesUpdatedMutex.Lock()
	ret, specificReturn := fake.configOverridesUpdatedReturnsOnCall[len(fake.configOverridesUpdatedArgsForCall)]
	fake.configOverridesUpdatedArgsForCall = append(fake.configOverridesUpdatedArgsForCall, struct {
	}{})
	stub := fake.ConfigOverridesUpdatedStub
	fakeReturns := fake.configOverridesUpdatedReturns
	fake.recordInvocation("ConfigOverridesUpdated", []interface{}{})
	fake.configOverridesUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) ConfigOverridesUpdatedCallCount() int {
	fake.configOverridesUpdatedMutex.RLock()
	defer fake.configOverridesUpdatedMutex.RUnlock()
	return len(fake.configOverridesUpdatedArgsForCall)
}

func (fake *Update) ConfigOverridesUpdatedCalls(stub func() bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = stub
}

func (fake *Update) ConfigOverridesUpdatedReturns(result1 bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = nil
	fake.configOverridesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ConfigOverridesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = nil
	if fake.configOverridesUpdatedReturnsOnCall == nil {
		fake.configOverridesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.configOverridesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CryptoBackupNeeded() bool {
	fake.cryptoBackupNeededMutex.Lock()
	ret, specificReturn := fake.cryptoBackupNeededReturnsOnCall[len(fake.cryptoBackupNeededArgsForCall)]
	fake.cryptoBackupNeededArgsForCall = append(fake.cryptoBackupNeededArgsForCall, struct {
	}{})
	stub := fake.CryptoBackupNeededStub
	fakeReturns := fake.cryptoBackupNeededReturns
	fake.recordInvocation("CryptoBackupNeeded", []interface{}{})
	fake.cryptoBackupNeededMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) CryptoBackupNeededCallCount() int {
	fake.cryptoBackupNeededMutex.RLock()
	defer fake.cryptoBackupNeededMutex.RUnlock()
	return len(fake.cryptoBackupNeededArgsForCall)
}

func (fake *Update) CryptoBackupNeededCalls(stub func() bool) {
	fake.cryptoBackupNeededMutex.Lock()
	defer fake.cryptoBackupNeededMutex.Unlock()
	fake.CryptoBackupNeededStub = stub
}

func (fake *Update) CryptoBackupNeededReturns(result1 bool) {
	fake.cryptoBackupNeededMutex.Lock()
	defer fake.cryptoBackupNeededMutex.Unlock()
	fake.CryptoBackupNeededStub = nil
	fake.cryptoBackupNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CryptoBackupNeededReturnsOnCall(i int, result1 bool) {
	fake.cryptoBackupNeededMutex.Lock()
	defer fake.cryptoBackupNeededMutex.Unlock()
	fake.CryptoBackupNeededStub = nil
	if fake.cryptoBackupNeededReturnsOnCall == nil {
		fake.cryptoBackupNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cryptoBackupNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) DeploymentUpdated() bool {
	fake.deploymentUpdatedMutex.Lock()
	ret, specificReturn := fake.deploymentUpdatedReturnsOnCall[len(fake.deploymentUpdatedArgsForCall)]
	fake.deploymentUpdatedArgsForCall = append(fake.deploymentUpdatedArgsForCall, struct {
	}{})
	stub := fake.DeploymentUpdatedStub
	fakeReturns := fake.deploymentUpdatedReturns
	fake.recordInvocation("DeploymentUpdated", []interface{}{})
	fake.deploymentUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) DeploymentUpdatedCallCount() int {
	fake.deploymentUpdatedMutex.RLock()
	defer fake.deploymentUpdatedMutex.RUnlock()
	return len(fake.deploymentUpdatedArgsForCall)
}

func (fake *Update) DeploymentUpdatedCalls(stub func() bool) {
	fake.deploymentUpdatedMutex.Lock()
	defer fake.deploymentUpdatedMutex.Unlock()
	fake.DeploymentUpdatedStub = stub
}

func (fake *Update) DeploymentUpdatedReturns(result1 bool) {
	fake.deploymentUpdatedMutex.Lock()
	defer fake.deploymentUpdatedMutex.Unlock()
	fake.DeploymentUpdatedStub = nil
	fake.deploymentUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) DeploymentUpdatedReturnsOnCall(i int, result1 bool) {
	fake.deploymentUpdatedMutex.Lock()
	defer fake.deploymentUpdatedMutex.Unlock()
	fake.DeploymentUpdatedStub = nil
	if fake.deploymentUpdatedReturnsOnCall == nil {
		fake.deploymentUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.deploymentUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertEnroll() bool {
	fake.ecertEnrollMutex.Lock()
	ret, specificReturn := fake.ecertEnrollReturnsOnCall[len(fake.ecertEnrollArgsForCall)]
	fake.ecertEnrollArgsForCall = append(fake.ecertEnrollArgsForCall, struct {
	}{})
	stub := fake.EcertEnrollStub
	fakeReturns := fake.ecertEnrollReturns
	fake.recordInvocation("EcertEnroll", []interface{}{})
	fake.ecertEnrollMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) EcertEnrollCallCount() int {
	fake.ecertEnrollMutex.RLock()
	defer fake.ecertEnrollMutex.RUnlock()
	return len(fake.ecertEnrollArgsForCall)
}

func (fake *Update) EcertEnrollCalls(stub func() bool) {
	fake.ecertEnrollMutex.Lock()
	defer fake.ecertEnrollMutex.Unlock()
	fake.EcertEnrollStub = stub
}

func (fake *Update) EcertEnrollReturns(result1 bool) {
	fake.ecertEnrollMutex.Lock()
	defer fake.ecertEnrollMutex.Unlock()
	fake.EcertEnrollStub = nil
	fake.ecertEnrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertEnrollReturnsOnCall(i int, result1 bool) {
	fake.ecertEnrollMutex.Lock()
	defer fake.ecertEnrollMutex.Unlock()
	fake.EcertEnrollStub = nil
	if fake.ecertEnrollReturnsOnCall == nil {
		fake.ecertEnrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertEnrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertNewKeyReenroll() bool {
	fake.ecertNewKeyReenrollMutex.Lock()
	ret, specificReturn := fake.ecertNewKeyReenrollReturnsOnCall[len(fake.ecertNewKeyReenrollArgsForCall)]
	fake.ecertNewKeyReenrollArgsForCall = append(fake.ecertNewKeyReenrollArgsForCall, struct {
	}{})
	stub := fake.EcertNewKeyReenrollStub
	fakeReturns := fake.ecertNewKeyReenrollReturns
	fake.recordInvocation("EcertNewKeyReenroll", []interface{}{})
	fake.ecertNewKeyReenrollMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) EcertNewKeyReenrollCallCount() int {
	fake.ecertNewKeyReenrollMutex.RLock()
	defer fake.ecertNewKeyReenrollMutex.RUnlock()
	return len(fake.ecertNewKeyReenrollArgsForCall)
}

func (fake *Update) EcertNewKeyReenrollCalls(stub func() bool) {
	fake.ecertNewKeyReenrollMutex.Lock()
	defer fake.ecertNewKeyReenrollMutex.Unlock()
	fake.EcertNewKeyReenrollStub = stub
}

func (fake *Update) EcertNewKeyReenrollReturns(result1 bool) {
	fake.ecertNewKeyReenrollMutex.Lock()
	defer fake.ecertNewKeyReenrollMutex.Unlock()
	fake.EcertNewKeyReenrollStub = nil
	fake.ecertNewKeyReenrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertNewKeyReenrollReturnsOnCall(i int, result1 bool) {
	fake.ecertNewKeyReenrollMutex.Lock()
	defer fake.ecertNewKeyReenrollMutex.Unlock()
	fake.EcertNewKeyReenrollStub = nil
	if fake.ecertNewKeyReenrollReturnsOnCall == nil {
		fake.ecertNewKeyReenrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertNewKeyReenrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertReenrollNeeded() bool {
	fake.ecertReenrollNeededMutex.Lock()
	ret, specificReturn := fake.ecertReenrollNeededReturnsOnCall[len(fake.ecertReenrollNeededArgsForCall)]
	fake.ecertReenrollNeededArgsForCall = append(fake.ecertReenrollNeededArgsForCall, struct {
	}{})
	stub := fake.EcertReenrollNeededStub
	fakeReturns := fake.ecertReenrollNeededReturns
	fake.recordInvocation("EcertReenrollNeeded", []interface{}{})
	fake.ecertReenrollNeededMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) EcertReenrollNeededCallCount() int {
	fake.ecertReenrollNeededMutex.RLock()
	defer fake.ecertReenrollNeededMutex.RUnlock()
	return len(fake.ecertReenrollNeededArgsForCall)
}

func (fake *Update) EcertReenrollNeededCalls(stub func() bool) {
	fake.ecertReenrollNeededMutex.Lock()
	defer fake.ecertReenrollNeededMutex.Unlock()
	fake.EcertReenrollNeededStub = stub
}

func (fake *Update) EcertReenrollNeededReturns(result1 bool) {
	fake.ecertReenrollNeededMutex.Lock()
	defer fake.ecertReenrollNeededMutex.Unlock()
	fake.EcertReenrollNeededStub = nil
	fake.ecertReenrollNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertReenrollNeededReturnsOnCall(i int, result1 bool) {
	fake.ecertReenrollNeededMutex.Lock()
	defer fake.ecertReenrollNeededMutex.Unlock()
	fake.EcertReenrollNeededStub = nil
	if fake.ecertReenrollNeededReturnsOnCall == nil {
		fake.ecertReenrollNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertReenrollNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertUpdated() bool {
	fake.ecertUpdatedMutex.Lock()
	ret, specificReturn := fake.ecertUpdatedReturnsOnCall[len(fake.ecertUpdatedArgsForCall)]
	fake.ecertUpdatedArgsForCall = append(fake.ecertUpdatedArgsForCall, struct {
	}{})
	stub := fake.EcertUpdatedStub
	fakeReturns := fake.ecertUpdatedReturns
	fake.recordInvocation("EcertUpdated", []interface{}{})
	fake.ecertUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) EcertUpdatedCallCount() int {
	fake.ecertUpdatedMutex.RLock()
	defer fake.ecertUpdatedMutex.RUnlock()
	return len(fake.ecertUpdatedArgsForCall)
}

func (fake *Update) EcertUpdatedCalls(stub func() bool) {
	fake.ecertUpdatedMutex.Lock()
	defer fake.ecertUpdatedMutex.Unlock()
	fake.EcertUpdatedStub = stub
}

func (fake *Update) EcertUpdatedReturns(result1 bool) {
	fake.ecertUpdatedMutex.Lock()
	defer fake.ecertUpdatedMutex.Unlock()
	fake.EcertUpdatedStub = nil
	fake.ecertUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertUpdatedReturnsOnCall(i int, result1 bool) {
	fake.ecertUpdatedMutex.Lock()
	defer fake.ecertUpdatedMutex.Unlock()
	fake.EcertUpdatedStub = nil
	if fake.ecertUpdatedReturnsOnCall == nil {
		fake.ecertUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) FabricVersionUpdated() bool {
	fake.fabricVersionUpdatedMutex.Lock()
	ret, specificReturn := fake.fabricVersionUpdatedReturnsOnCall[len(fake.fabricVersionUpdatedArgsForCall)]
	fake.fabricVersionUpdatedArgsForCall = append(fake.fabricVersionUpdatedArgsForCall, struct {
	}{})
	stub := fake.FabricVersionUpdatedStub
	fakeReturns := fake.fabricVersionUpdatedReturns
	fake.recordInvocation("FabricVersionUpdated", []interface{}{})
	fake.fabricVersionUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) FabricVersionUpdatedCallCount() int {
	fake.fabricVersionUpdatedMutex.RLock()
	defer fake.fabricVersionUpdatedMutex.RUnlock()
	return len(fake.fabricVersionUpdatedArgsForCall)
}

func (fake *Update) FabricVersionUpdatedCalls(stub func() bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = stub
}

func (fake *Update) FabricVersionUpdatedReturns(result1 bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = nil
	fake.fabricVersionUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) FabricVersionUpdatedReturnsOnCall(i int, result1 bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = nil
	if fake.fabricVersionUpdatedReturnsOnCall == nil {
		fake.fabricVersionUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.fabricVersionUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) GetCreatedCertType() common.SecretType {
	fake.getCreatedCertTypeMutex.Lock()
	ret, specificReturn := fake.getCreatedCertTypeReturnsOnCall[len(fake.getCreatedCertTypeArgsForCall)]
	fake.getCreatedCertTypeArgsForCall = append(fake.getCreatedCertTypeArgsForCall, struct {
	}{})
	stub := fake.GetCreatedCertTypeStub
	fakeReturns := fake.getCreatedCertTypeReturns
	fake.recordInvocation("GetCreatedCertType", []interface{}{})
	fake.getCreatedCertTypeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) GetCreatedCertTypeCallCount() int {
	fake.getCreatedCertTypeMutex.RLock()
	defer fake.getCreatedCertTypeMutex.RUnlock()
	return len(fake.getCreatedCertTypeArgsForCall)
}

func (fake *Update) GetCreatedCertTypeCalls(stub func() common.SecretType) {
	fake.getCreatedCertTypeMutex.Lock()
	defer fake.getCreatedCertTypeMutex.Unlock()
	fake.GetCreatedCertTypeStub = stub
}

func (fake *Update) GetCreatedCertTypeReturns(result1 common.SecretType) {
	fake.getCreatedCertTypeMutex.Lock()
	defer fake.getCreatedCertTypeMutex.Unlock()
	fake.GetCreatedCertTypeStub = nil
	fake.getCreatedCertTypeReturns = struct {
		result1 common.SecretType
	}{result1}
}

func (fake *Update) GetCreatedCertTypeReturnsOnCall(i int, result1 common.SecretType) {
	fake.getCreatedCertTypeMutex.Lock()
	defer fake.getCreatedCertTypeMutex.Unlock()
	fake.GetCreatedCertTypeStub = nil
	if fake.getCreatedCertTypeReturnsOnCall == nil {
		fake.getCreatedCertTypeReturnsOnCall = make(map[int]struct {
			result1 common.SecretType
		})
	}
	fake.getCreatedCertTypeReturnsOnCall[i] = struct {
		result1 common.SecretType
	}{result1}
}

func (fake *Update) ImagesUpdated() bool {
	fake.imagesUpdatedMutex.Lock()
	ret, specificReturn := fake.imagesUpdatedReturnsOnCall[len(fake.imagesUpdatedArgsForCall)]
	fake.imagesUpdatedArgsForCall = append(fake.imagesUpdatedArgsForCall, struct {
	}{})
	stub := fake.ImagesUpdatedStub
	fakeReturns := fake.imagesUpdatedReturns
	fake.recordInvocation("ImagesUpdated", []interface{}{})
	fake.imagesUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) ImagesUpdatedCallCount() int {
	fake.imagesUpdatedMutex.RLock()
	defer fake.imagesUpdatedMutex.RUnlock()
	return len(fake.imagesUpdatedArgsForCall)
}

func (fake *Update) ImagesUpdatedCalls(stub func() bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = stub
}

func (fake *Update) ImagesUpdatedReturns(result1 bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = nil
	fake.imagesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ImagesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = nil
	if fake.imagesUpdatedReturnsOnCall == nil {
		fake.imagesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.imagesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MSPUpdated() bool {
	fake.mSPUpdatedMutex.Lock()
	ret, specificReturn := fake.mSPUpdatedReturnsOnCall[len(fake.mSPUpdatedArgsForCall)]
	fake.mSPUpdatedArgsForCall = append(fake.mSPUpdatedArgsForCall, struct {
	}{})
	stub := fake.MSPUpdatedStub
	fakeReturns := fake.mSPUpdatedReturns
	fake.recordInvocation("MSPUpdated", []interface{}{})
	fake.mSPUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) MSPUpdatedCallCount() int {
	fake.mSPUpdatedMutex.RLock()
	defer fake.mSPUpdatedMutex.RUnlock()
	return len(fake.mSPUpdatedArgsForCall)
}

func (fake *Update) MSPUpdatedCalls(stub func() bool) {
	fake.mSPUpdatedMutex.Lock()
	defer fake.mSPUpdatedMutex.Unlock()
	fake.MSPUpdatedStub = stub
}

func (fake *Update) MSPUpdatedReturns(result1 bool) {
	fake.mSPUpdatedMutex.Lock()
	defer fake.mSPUpdatedMutex.Unlock()
	fake.MSPUpdatedStub = nil
	fake.mSPUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MSPUpdatedReturnsOnCall(i int, result1 bool) {
	fake.mSPUpdatedMutex.Lock()
	defer fake.mSPUpdatedMutex.Unlock()
	fake.MSPUpdatedStub = nil
	if fake.mSPUpdatedReturnsOnCall == nil {
		fake.mSPUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.mSPUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV2() bool {
	fake.migrateToV2Mutex.Lock()
	ret, specificReturn := fake.migrateToV2ReturnsOnCall[len(fake.migrateToV2ArgsForCall)]
	fake.migrateToV2ArgsForCall = append(fake.migrateToV2ArgsForCall, struct {
	}{})
	stub := fake.MigrateToV2Stub
	fakeReturns := fake.migrateToV2Returns
	fake.recordInvocation("MigrateToV2", []interface{}{})
	fake.migrateToV2Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) MigrateToV2CallCount() int {
	fake.migrateToV2Mutex.RLock()
	defer fake.migrateToV2Mutex.RUnlock()
	return len(fake.migrateToV2ArgsForCall)
}

func (fake *Update) MigrateToV2Calls(stub func() bool) {
	fake.migrateToV2Mutex.Lock()
	defer fake.migrateToV2Mutex.Unlock()
	fake.MigrateToV2Stub = stub
}

func (fake *Update) MigrateToV2Returns(result1 bool) {
	fake.migrateToV2Mutex.Lock()
	defer fake.migrateToV2Mutex.Unlock()
	fake.MigrateToV2Stub = nil
	fake.migrateToV2Returns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV2ReturnsOnCall(i int, result1 bool) {
	fake.migrateToV2Mutex.Lock()
	defer fake.migrateToV2Mutex.Unlock()
	fake.MigrateToV2Stub = nil
	if fake.migrateToV2ReturnsOnCall == nil {
		fake.migrateToV2ReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.migrateToV2ReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV24() bool {
	fake.migrateToV24Mutex.Lock()
	ret, specificReturn := fake.migrateToV24ReturnsOnCall[len(fake.migrateToV24ArgsForCall)]
	fake.migrateToV24ArgsForCall = append(fake.migrateToV24ArgsForCall, struct {
	}{})
	stub := fake.MigrateToV24Stub
	fakeReturns := fake.migrateToV24Returns
	fake.recordInvocation("MigrateToV24", []interface{}{})
	fake.migrateToV24Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) MigrateToV24CallCount() int {
	fake.migrateToV24Mutex.RLock()
	defer fake.migrateToV24Mutex.RUnlock()
	return len(fake.migrateToV24ArgsForCall)
}

func (fake *Update) MigrateToV24Calls(stub func() bool) {
	fake.migrateToV24Mutex.Lock()
	defer fake.migrateToV24Mutex.Unlock()
	fake.MigrateToV24Stub = stub
}

func (fake *Update) MigrateToV24Returns(result1 bool) {
	fake.migrateToV24Mutex.Lock()
	defer fake.migrateToV24Mutex.Unlock()
	fake.MigrateToV24Stub = nil
	fake.migrateToV24Returns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV24ReturnsOnCall(i int, result1 bool) {
	fake.migrateToV24Mutex.Lock()
	defer fake.migrateToV24Mutex.Unlock()
	fake.MigrateToV24Stub = nil
	if fake.migrateToV24ReturnsOnCall == nil {
		fake.migrateToV24ReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.migrateToV24ReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV25() bool {
	fake.migrateToV25Mutex.Lock()
	ret, specificReturn := fake.migrateToV25ReturnsOnCall[len(fake.migrateToV25ArgsForCall)]
	fake.migrateToV25ArgsForCall = append(fake.migrateToV25ArgsForCall, struct {
	}{})
	stub := fake.MigrateToV25Stub
	fakeReturns := fake.migrateToV25Returns
	fake.recordInvocation("MigrateToV25", []interface{}{})
	fake.migrateToV25Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) MigrateToV25CallCount() int {
	fake.migrateToV25Mutex.RLock()
	defer fake.migrateToV25Mutex.RUnlock()
	return len(fake.migrateToV25ArgsForCall)
}

func (fake *Update) MigrateToV25Calls(stub func() bool) {
	fake.migrateToV25Mutex.Lock()
	defer fake.migrateToV25Mutex.Unlock()
	fake.MigrateToV25Stub = stub
}

func (fake *Update) MigrateToV25Returns(result1 bool) {
	fake.migrateToV25Mutex.Lock()
	defer fake.migrateToV25Mutex.Unlock()
	fake.MigrateToV25Stub = nil
	fake.migrateToV25Returns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV25ReturnsOnCall(i int, result1 bool) {
	fake.migrateToV25Mutex.Lock()
	defer fake.migrateToV25Mutex.Unlock()
	fake.MigrateToV25Stub = nil
	if fake.migrateToV25ReturnsOnCall == nil {
		fake.migrateToV25ReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.migrateToV25ReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) NodeOUUpdated() bool {
	fake.nodeOUUpdatedMutex.Lock()
	ret, specificReturn := fake.nodeOUUpdatedReturnsOnCall[len(fake.nodeOUUpdatedArgsForCall)]
	fake.nodeOUUpdatedArgsForCall = append(fake.nodeOUUpdatedArgsForCall, struct {
	}{})
	stub := fake.NodeOUUpdatedStub
	fakeReturns := fake.nodeOUUpdatedReturns
	fake.recordInvocation("NodeOUUpdated", []interface{}{})
	fake.nodeOUUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) NodeOUUpdatedCallCount() int {
	fake.nodeOUUpdatedMutex.RLock()
	defer fake.nodeOUUpdatedMutex.RUnlock()
	return len(fake.nodeOUUpdatedArgsForCall)
}

func (fake *Update) NodeOUUpdatedCalls(stub func() bool) {
	fake.nodeOUUpdatedMutex.Lock()
	defer fake.nodeOUUpdatedMutex.Unlock()
	fake.NodeOUUpdatedStub = stub
}

func (fake *Update) NodeOUUpdatedReturns(result1 bool) {
	fake.nodeOUUpdatedMutex.Lock()
	defer fake.nodeOUUpdatedMutex.Unlock()
	fake.NodeOUUpdatedStub = nil
	fake.nodeOUUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) NodeOUUpdatedReturnsOnCall(i int, result1 bool) {
	fake.nodeOUUpdatedMutex.Lock()
	defer fake.nodeOUUpdatedMutex.Unlock()
	fake.NodeOUUpdatedStub = nil
	if fake.nodeOUUpdatedReturnsOnCall == nil {
		fake.nodeOUUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.nodeOUUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) OrdererTagUpdated() bool {
	fake.ordererTagUpdatedMutex.Lock()
	ret, specificReturn := fake.ordererTagUpdatedReturnsOnCall[len(fake.ordererTagUpdatedArgsForCall)]
	fake.ordererTagUpdatedArgsForCall = append(fake.ordererTagUpdatedArgsForCall, struct {
	}{})
	stub := fake.OrdererTagUpdatedStub
	fakeReturns := fake.ordererTagUpdatedReturns
	fake.recordInvocation("OrdererTagUpdated", []interface{}{})
	fake.ordererTagUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) OrdererTagUpdatedCallCount() int {
	fake.ordererTagUpdatedMutex.RLock()
	defer fake.ordererTagUpdatedMutex.RUnlock()
	return len(fake.ordererTagUpdatedArgsForCall)
}

func (fake *Update) OrdererTagUpdatedCalls(stub func() bool) {
	fake.ordererTagUpdatedMutex.Lock()
	defer fake.ordererTagUpdatedMutex.Unlock()
	fake.OrdererTagUpdatedStub = stub
}

func (fake *Update) OrdererTagUpdatedReturns(result1 bool) {
	fake.ordererTagUpdatedMutex.Lock()
	defer fake.ordererTagUpdatedMutex.Unlock()
	fake.OrdererTagUpdatedStub = nil
	fake.ordererTagUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) OrdererTagUpdatedReturnsOnCall(i int, result1 bool) {
	fake.ordererTagUpdatedMutex.Lock()
	defer fake.ordererTagUpdatedMutex.Unlock()
	fake.OrdererTagUpdatedStub = nil
	if fake.ordererTagUpdatedReturnsOnCall == nil {
		fake.ordererTagUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ordererTagUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RestartNeeded() bool {
	fake.restartNeededMutex.Lock()
	ret, specificReturn := fake.restartNeededReturnsOnCall[len(fake.restartNeededArgsForCall)]
	fake.restartNeededArgsForCall = append(fake.restartNeededArgsForCall, struct {
	}{})
	stub := fake.RestartNeededStub
	fakeReturns := fake.restartNeededReturns
	fake.recordInvocation("RestartNeeded", []interface{}{})
	fake.restartNeededMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) RestartNeededCallCount() int {
	fake.restartNeededMutex.RLock()
	defer fake.restartNeededMutex.RUnlock()
	return len(fake.restartNeededArgsForCall)
}

func (fake *Update) RestartNeededCalls(stub func() bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = stub
}

func (fake *Update) RestartNeededReturns(result1 bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = nil
	fake.restartNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RestartNeededReturnsOnCall(i int, result1 bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = nil
	if fake.restartNeededReturnsOnCall == nil {
		fake.restartNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.restartNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) SpecUpdated() bool {
	fake.specUpdatedMutex.Lock()
	ret, specificReturn := fake.specUpdatedReturnsOnCall[len(fake.specUpdatedArgsForCall)]
	fake.specUpdatedArgsForCall = append(fake.specUpdatedArgsForCall, struct {
	}{})
	stub := fake.SpecUpdatedStub
	fakeReturns := fake.specUpdatedReturns
	fake.recordInvocation("SpecUpdated", []interface{}{})
	fake.specUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) SpecUpdatedCallCount() int {
	fake.specUpdatedMutex.RLock()
	defer fake.specUpdatedMutex.RUnlock()
	return len(fake.specUpdatedArgsForCall)
}

func (fake *Update) SpecUpdatedCalls(stub func() bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = stub
}

func (fake *Update) SpecUpdatedReturns(result1 bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = nil
	fake.specUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) SpecUpdatedReturnsOnCall(i int, result1 bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = nil
	if fake.specUpdatedReturnsOnCall == nil {
		fake.specUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.specUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCertUpdated() bool {
	fake.tLSCertUpdatedMutex.Lock()
	ret, specificReturn := fake.tLSCertUpdatedReturnsOnCall[len(fake.tLSCertUpdatedArgsForCall)]
	fake.tLSCertUpdatedArgsForCall = append(fake.tLSCertUpdatedArgsForCall, struct {
	}{})
	stub := fake.TLSCertUpdatedStub
	fakeReturns := fake.tLSCertUpdatedReturns
	fake.recordInvocation("TLSCertUpdated", []interface{}{})
	fake.tLSCertUpdatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) TLSCertUpdatedCallCount() int {
	fake.tLSCertUpdatedMutex.RLock()
	defer fake.tLSCertUpdatedMutex.RUnlock()
	return len(fake.tLSCertUpdatedArgsForCall)
}

func (fake *Update) TLSCertUpdatedCalls(stub func() bool) {
	fake.tLSCertUpdatedMutex.Lock()
	defer fake.tLSCertUpdatedMutex.Unlock()
	fake.TLSCertUpdatedStub = stub
}

func (fake *Update) TLSCertUpdatedReturns(result1 bool) {
	fake.tLSCertUpdatedMutex.Lock()
	defer fake.tLSCertUpdatedMutex.Unlock()
	fake.TLSCertUpdatedStub = nil
	fake.tLSCertUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCertUpdatedReturnsOnCall(i int, result1 bool) {
	fake.tLSCertUpdatedMutex.Lock()
	defer fake.tLSCertUpdatedMutex.Unlock()
	fake.TLSCertUpdatedStub = nil
	if fake.tLSCertUpdatedReturnsOnCall == nil {
		fake.tLSCertUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLSCertUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertEnroll() bool {
	fake.tLScertEnrollMutex.Lock()
	ret, specificReturn := fake.tLScertEnrollReturnsOnCall[len(fake.tLScertEnrollArgsForCall)]
	fake.tLScertEnrollArgsForCall = append(fake.tLScertEnrollArgsForCall, struct {
	}{})
	stub := fake.TLScertEnrollStub
	fakeReturns := fake.tLScertEnrollReturns
	fake.recordInvocation("TLScertEnroll", []interface{}{})
	fake.tLScertEnrollMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) TLScertEnrollCallCount() int {
	fake.tLScertEnrollMutex.RLock()
	defer fake.tLScertEnrollMutex.RUnlock()
	return len(fake.tLScertEnrollArgsForCall)
}

func (fake *Update) TLScertEnrollCalls(stub func() bool) {
	fake.tLScertEnrollMutex.Lock()
	defer fake.tLScertEnrollMutex.Unlock()
	fake.TLScertEnrollStub = stub
}

func (fake *Update) TLScertEnrollReturns(result1 bool) {
	fake.tLScertEnrollMutex.Lock()
	defer fake.tLScertEnrollMutex.Unlock()
	fake.TLScertEnrollStub = nil
	fake.tLScertEnrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertEnrollReturnsOnCall(i int, result1 bool) {
	fake.tLScertEnrollMutex.Lock()
	defer fake.tLScertEnrollMutex.Unlock()
	fake.TLScertEnrollStub = nil
	if fake.tLScertEnrollReturnsOnCall == nil {
		fake.tLScertEnrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLScertEnrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertNewKeyReenroll() bool {
	fake.tLScertNewKeyReenrollMutex.Lock()
	ret, specificReturn := fake.tLScertNewKeyReenrollReturnsOnCall[len(fake.tLScertNewKeyReenrollArgsForCall)]
	fake.tLScertNewKeyReenrollArgsForCall = append(fake.tLScertNewKeyReenrollArgsForCall, struct {
	}{})
	stub := fake.TLScertNewKeyReenrollStub
	fakeReturns := fake.tLScertNewKeyReenrollReturns
	fake.recordInvocation("TLScertNewKeyReenroll", []interface{}{})
	fake.tLScertNewKeyReenrollMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) TLScertNewKeyReenrollCallCount() int {
	fake.tLScertNewKeyReenrollMutex.RLock()
	defer fake.tLScertNewKeyReenrollMutex.RUnlock()
	return len(fake.tLScertNewKeyReenrollArgsForCall)
}

func (fake *Update) TLScertNewKeyReenrollCalls(stub func() bool) {
	fake.tLScertNewKeyReenrollMutex.Lock()
	defer fake.tLScertNewKeyReenrollMutex.Unlock()
	fake.TLScertNewKeyReenrollStub = stub
}

func (fake *Update) TLScertNewKeyReenrollReturns(result1 bool) {
	fake.tLScertNewKeyReenrollMutex.Lock()
	defer fake.tLScertNewKeyReenrollMutex.Unlock()
	fake.TLScertNewKeyReenrollStub = nil
	fake.tLScertNewKeyReenrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertNewKeyReenrollReturnsOnCall(i int, result1 bool) {
	fake.tLScertNewKeyReenrollMutex.Lock()
	defer fake.tLScertNewKeyReenrollMutex.Unlock()
	fake.TLScertNewKeyReenrollStub = nil
	if fake.tLScertNewKeyReenrollReturnsOnCall == nil {
		fake.tLScertNewKeyReenrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLScertNewKeyReenrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertReenrollNeeded() bool {
	fake.tLScertReenrollNeededMutex.Lock()
	ret, specificReturn := fake.tLScertReenrollNeededReturnsOnCall[len(fake.tLScertReenrollNeededArgsForCall)]
	fake.tLScertReenrollNeededArgsForCall = append(fake.tLScertReenrollNeededArgsForCall, struct {
	}{})
	stub := fake.TLScertReenrollNeededStub
	fakeReturns := fake.tLScertReenrollNeededReturns
	fake.recordInvocation("TLScertReenrollNeeded", []interface{}{})
	fake.tLScertReenrollNeededMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Update) TLScertReenrollNeededCallCount() int {
	fake.tLScertReenrollNeededMutex.RLock()
	defer fake.tLScertReenrollNeededMutex.RUnlock()
	return len(fake.tLScertReenrollNeededArgsForCall)
}

func (fake *Update) TLScertReenrollNeededCalls(stub func() bool) {
	fake.tLScertReenrollNeededMutex.Lock()
	defer fake.tLScertReenrollNeededMutex.Unlock()
	fake.TLScertReenrollNeededStub = stub
}

func (fake *Update) TLScertReenrollNeededReturns(result1 bool) {
	fake.tLScertReenrollNeededMutex.Lock()
	defer fake.tLScertReenrollNeededMutex.Unlock()
	fake.TLScertReenrollNeededStub = nil
	fake.tLScertReenrollNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertReenrollNeededReturnsOnCall(i int, result1 bool) {
	fake.tLScertReenrollNeededMutex.Lock()
	defer fake.tLScertReenrollNeededMutex.Unlock()
	fake.TLScertReenrollNeededStub = nil
	if fake.tLScertReenrollNeededReturnsOnCall == nil {
		fake.tLScertReenrollNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLScertReenrollNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.certificateCreatedMutex.RLock()
	defer fake.certificateCreatedMutex.RUnlock()
	fake.certificateUpdatedMutex.RLock()
	defer fake.certificateUpdatedMutex.RUnlock()
	fake.configOverridesUpdatedMutex.RLock()
	defer fake.configOverridesUpdatedMutex.RUnlock()
	fake.cryptoBackupNeededMutex.RLock()
	defer fake.cryptoBackupNeededMutex.RUnlock()
	fake.deploymentUpdatedMutex.RLock()
	defer fake.deploymentUpdatedMutex.RUnlock()
	fake.ecertEnrollMutex.RLock()
	defer fake.ecertEnrollMutex.RUnlock()
	fake.ecertNewKeyReenrollMutex.RLock()
	defer fake.ecertNewKeyReenrollMutex.RUnlock()
	fake.ecertReenrollNeededMutex.RLock()
	defer fake.ecertReenrollNeededMutex.RUnlock()
	fake.ecertUpdatedMutex.RLock()
	defer fake.ecertUpdatedMutex.RUnlock()
	fake.fabricVersionUpdatedMutex.RLock()
	defer fake.fabricVersionUpdatedMutex.RUnlock()
	fake.getCreatedCertTypeMutex.RLock()
	defer fake.getCreatedCertTypeMutex.RUnlock()
	fake.imagesUpdatedMutex.RLock()
	defer fake.imagesUpdatedMutex.RUnlock()
	fake.mSPUpdatedMutex.RLock()
	defer fake.mSPUpdatedMutex.RUnlock()
	fake.migrateToV2Mutex.RLock()
	defer fake.migrateToV2Mutex.RUnlock()
	fake.migrateToV24Mutex.RLock()
	defer fake.migrateToV24Mutex.RUnlock()
	fake.migrateToV25Mutex.RLock()
	defer fake.migrateToV25Mutex.RUnlock()
	fake.nodeOUUpdatedMutex.RLock()
	defer fake.nodeOUUpdatedMutex.RUnlock()
	fake.ordererTagUpdatedMutex.RLock()
	defer fake.ordererTagUpdatedMutex.RUnlock()
	fake.restartNeededMutex.RLock()
	defer fake.restartNeededMutex.RUnlock()
	fake.specUpdatedMutex.RLock()
	defer fake.specUpdatedMutex.RUnlock()
	fake.tLSCertUpdatedMutex.RLock()
	defer fake.tLSCertUpdatedMutex.RUnlock()
	fake.tLScertEnrollMutex.RLock()
	defer fake.tLScertEnrollMutex.RUnlock()
	fake.tLScertNewKeyReenrollMutex.RLock()
	defer fake.tLScertNewKeyReenrollMutex.RUnlock()
	fake.tLScertReenrollNeededMutex.RLock()
	defer fake.tLScertReenrollNeededMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Update) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ baseorderer.Update = new(Update)
