/*
 * Copyright contributors to the Hyperledger Fabric Operator project
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 * 	  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/IBM-Blockchain/fabric-operator/pkg/util"
	"github.com/pkg/errors"
)

type DBType string

var (
	SQLLite  DBType = "sqlite3"
	Postgres DBType = "postgres"
	MySQL    DBType = "mysql"
)

func (c *Config) ParseDBBlock() (map[string][]byte, error) {
	dbType := c.ServerConfig.CAConfig.DB.Type

	// Default to sqlite
	if dbType == "" {
		dbType = "sqlite3"
	}

	switch DBType(strings.ToLower(dbType)) {
	case SQLLite:
		// SQLite generated by operator during initilization is temporary.
		// The purpose of initilization is to generate crypto not for user data persistence.
		// Using a temporary path suffices for the purpose of sqlite based initilization.
		c.ServerConfig.CAConfig.DB.Datasource = "/tmp/db/ca.db"
		err := util.EnsureDir(filepath.Dir(c.ServerConfig.CAConfig.DB.Datasource))
		if err != nil {
			return nil, err
		}

		return nil, nil
	case Postgres:
		if !c.ServerConfig.CAConfig.DB.TLS.IsEnabled() {
			return nil, nil
		}

		datasource := c.ServerConfig.CAConfig.DB.Datasource
		if datasource == "" {
			return nil, errors.Errorf("no datasource string specified for postgres")
		}

		if !IsValidPostgressDatasource(datasource) {
			return nil, errors.Errorf("datasource for postgres is not valid")
		}

		if c.dbCrypto == nil {
			c.dbCrypto = map[string][]byte{}
		}

		log.Info("Parsing DB block for Postgres database")
		certFiles := c.ServerConfig.CAConfig.DB.TLS.CertFiles
		for index, certFile := range certFiles {
			err := c.HandleCertInput(certFile, fmt.Sprintf("db-certfile%d.pem", index), c.dbCrypto)
			if err != nil {
				return nil, err
			}
			certFiles[index] = filepath.Join(c.HomeDir, fmt.Sprintf("db-certfile%d.pem", index))
		}
		c.ServerConfig.CAConfig.DB.TLS.CertFiles = certFiles

		certFile := c.ServerConfig.CAConfig.DB.TLS.Client.CertFile
		keyFile := c.ServerConfig.CAConfig.DB.TLS.Client.KeyFile
		if certFile != "" && keyFile != "" {
			log.Info("Client authentication information provided for database connection")
			err := c.HandleCertInput(certFile, "db-cert.pem", c.dbCrypto)
			if err != nil {
				return nil, err
			}
			c.ServerConfig.CAConfig.DB.TLS.Client.CertFile = filepath.Join(c.HomeDir, "db-cert.pem")

			err = c.HandleKeyInput(keyFile, "db-key.pem", c.dbCrypto)
			if err != nil {
				return nil, err
			}
			c.ServerConfig.CAConfig.DB.TLS.Client.KeyFile = filepath.Join(c.HomeDir, "db-key.pem")
		}

		return c.dbCrypto, nil
	case MySQL:
		return nil, errors.New("MySQL is not supported")
	}

	return nil, errors.Errorf("database type '%s' is not supported", dbType)
}

func (c *Config) DBMountPath() {
	certFile := c.ServerConfig.CAConfig.DB.TLS.Client.CertFile
	keyFile := c.ServerConfig.CAConfig.DB.TLS.Client.KeyFile

	if certFile != "" && keyFile != "" {
		c.ServerConfig.CAConfig.DB.TLS.Client.CertFile = filepath.Join(c.MountPath, "db-cert.pem")
		c.ServerConfig.CAConfig.DB.TLS.Client.KeyFile = filepath.Join(c.MountPath, "db-key.pem")
	}

	certFiles := c.ServerConfig.CAConfig.DB.TLS.CertFiles
	for index := range certFiles {
		certFiles[index] = filepath.Join(c.MountPath, fmt.Sprintf("db-certfile%d.pem", index))
	}
	c.ServerConfig.CAConfig.DB.TLS.CertFiles = certFiles

	dbType := c.ServerConfig.CAConfig.DB.Type
	if DBType(strings.ToLower(dbType)) == SQLLite {
		if c.SqlitePath != "" {
			c.ServerConfig.CAConfig.DB.Datasource = c.SqlitePath
		} else {
			c.ServerConfig.CAConfig.DB.Datasource = "/data/db/ca.db"
		}
	}
}
